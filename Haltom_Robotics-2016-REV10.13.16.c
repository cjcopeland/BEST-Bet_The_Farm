#pragma config(Sensor, in2,    armPot,         sensorPotentiometer)
#pragma config(Sensor, in7,    scoopPot,       sensorPotentiometer)
#pragma config(Sensor, dgtl8,  upperLimit,     sensorTouch)
#pragma config(Sensor, dgtl10, lowerLimit,     sensorTouch)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, driveRight)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           seedDoorServo, tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           scoopMotor,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Begin Global variables
bool closeServo = true;
int btnOn = 1;
int btnOff = 0;
int maxPosThrottle = 127;
int maxNegThrottle = -127;
float minPercentThrottle = 0.05;
float maxPercentThrottle = 0.85;
int zeroThrottle = 0;
int servoMinPos = -127;
int servoMaxPos = 80;
//end Global variables
// I added this code!
//begin adjustThrottle function
//DESCRIPTION: 	take input from the VEX joystick and adjust it such that up to 85% throttle follows a squared input curve.
//							Above 85% input will be pushed to max throttle.  Below 5% throttle will be considered zero throttle.
int adjustThrottle(int input) {
	int output = 0;
	bool isPositive = false;
	if (input > minPercentThrottle * maxNegThrottle && input < minPercentThrottle * maxPosThrottle)
		return zeroThrottle;	//too little throttle, return zero
	if (input > zeroThrottle)
		isPositive = true;		//throttle is positive - needed for correct return output.
	if (input < maxPercentThrottle * maxNegThrottle || input > maxPercentThrottle * maxPosThrottle)
		return isPositive ? maxPosThrottle : maxNegThrottle;	//input throttle is above max threshold (85%), so return max throttle
	float percentThrottle = input / 127.0;
	output = isPositive ? maxPosThrottle * (percentThrottle * percentThrottle) : maxNegThrottle * (percentThrottle * percentThrottle);
	//output is adjusted using am input squared algorithm
	return output;
}
//end adjustThrottle

task main{
	while (true) {	//forever loop
		motor[port2] = adjustThrottle(vexRT[Ch2]);	//adjust right motor throttle
		motor[port3] = adjustThrottle(vexRT[Ch3]);	//adjust left motor throttle

		if (vexRT[Btn5D] == btnOn)	//if button 5D is pressed, lower the arm
			motor[port8] = maxPosThrottle;
		else if (vexRT[Btn5U] == btnOn)	//else if button 5U is pressed, raise the arm
			motor[port8] = maxNegThrottle;
		if (vexRT[Btn5D] == btnOff && vexRT[Btn5U] == btnOff)  //if neither button is pressed, cut power to the motor
			motor[port8] = zeroThrottle;



		if (vexRT[Btn6D] == btnOn && !SensorBoolean[dgtl8]) 	//if button 6D is pressed and the lower limit
			motor[port9] = maxPosThrottle;											//switch is NOT pressed then lower the scoop
		else if (vexRT[Btn6U] == btnOn && !SensorBoolean[dgtl10])	//else if button 6U is pressed and theupper
			motor[port9] = maxNegThrottle;													//limit switch is NOT pressed then raise the scoop
		if (vexRT[Btn6D] == btnOff && vexRT[Btn6U] == btnOff)	//if neither button is pressed, then cut power to the motor
			motor[port9] = zeroThrottle;
//TODO: come back and add potentiometer code once it has been physically added to the machine

		if (vexRT[Btn8U] == btnOn)		//if button 8U is pressed, then close the servo
			closeServo = false;
		if (vexRT[Btn8D] == btnOn)		//if button 8D is pressed, then open the servo
			closeServo = true;
		if (closeServo == true)				//open or close the servo depending on the
			motor[port6] = servoMinPos;	//current state of "closeServo"
		else
			motor[port6] = servoMaxPos;
	}	//end while
}
